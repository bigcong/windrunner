## 数据库设计三大范式
###第一范式
####无重复的列

每一列属性都是不可再分的属性，确保每一个列的原子性
两列的属性相近或者相似一样，尽量合并属性一样的列，确保不产生冗余的数据


就比如说，我们的user表设计，当中
```
select is_auth,is_auth_primary,is_auth_senior,is_auth_video,auth_level from user;
```
这几个字段，都可以用只用auth_level，状态来表示




### 第二范式
####属性完全依赖于主键
任意一个字段都只依赖表中的同一个字段

```
学生证 名称	学生证号	学生证办理时间	借书证名称	借书证号	借书证办理时间

```

改成2张表如下 学生证表

```
学生证	学生证号	学生证办理时间

```
借书证表

```
借书证	借书证号	借书证把你拉时间
```




### 第三范式
#### 属性不能传递依赖于主属性

如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键

学号, 姓名, 年龄, 所在学院, 学院联系电话，关键字为单一关键字"学号"; 
存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话) 



## 一些字段总结
#### DATETIME 和TIMESAMP 的区别
dateTime和timesamp列可以存储相同类型的数据：时间日期，精确到秒，然而timestamp只试用datetime一半的存储空间，并且会根据时区的变化，具有特殊更新能力，timestamp允许的范围比较小（ 1970-01-01 00:00:00 到 2037-12-31 23:59:59 ）（所以我们用记录创建时间和更新时间一般使用TIMESAMP，其他就用DATETIME）


### DECIMAL
因为CPU不支持DECIMAL的直接计算。对于DECIMAL列，可以指定小数点前后所允许的最大位数，这也会消耗更多的空间消耗。高版本的mysql会将DECIMAL打包存在一个二进制的字符串中，一种9个字节，小数点后用4个字节，小数点前用4个字节，小数点占一个字节。高版本mysql自身实现了高精度计算。相对而言，cpu直接支持浮点型计算，运行时间更快

### VARCHAR 和CHAR
#### VARCHAR
用于存储定可变的字符串，比定长类型更节省空间，varchar占用空间与存储的内容有关，需要使用1或2个额外字节记录字符串的长度，如果列的最大长度小于255，则使用1个字节，否则就需要2个字节，所以（字符串的最大长度比平均长度大很多）
varchar适合：字符串的最大长度比平均长度大很多


#### CHAR

char类型是定长的,适合存储很短的字符串，或者所有的都接近同一个长度。例如，char非常适合存储Md5值
定长的char类型不容易产生碎片，对于非常短的列，char比varchar在存储空间上也更有效率。char(1)只需要一个字节，而varchar(1)却需要两个字节，因为还有一个记录长度的额外字节



### BLOB和TEXT类型
BlOB类型存储的是二进制数据，没有排序规则或者字符集，而TEXT类型有字符集和排序规则
它只对每一个列的最前max_sort_length， 字节而不是整个字符串做排序。
不能将BLOB和TEXT列全部长度进行索引，也不能使用这些索引消除排序
使用枚举(ENUM)代替字符串类型
实际存储为整数，而不是字符串

### 使用枚举(ENUM)代替字符串类型

select e+0 form eum_test; 


### JSON 类型
#### 查询
```
select * from json_test where person_desc -> '$.genre'='3';

```



## MySQL Explain详解




#### ID
可以理解成sql的执行的标志，sql从大到小的执行

1. ID相同，执行顺序从上到下
2. 如果是子查询，id的序号就会递增，id值越大优先级就越高，越先越被执行
3. 如果id值相同，说明是一组，从上往下执行

```
explain select *,(select uuid from user limit 1)  from tr_order where customer_uuid in (select uuid from user);
```

#### select_type
查询类型

* SIMPLE

简单select,不使用union和子查询
```
explain select * from user
```

* PRIMARY

查询中如果包含临时表，那么外面的select被标记为PRIMARY

```
explain  select *  from (select *  from user ) a  limit 1;
```

* UNION 

UNION的第二个或者select语句被标记UNION

```
explain select uid from user union all select customer_uuid   from ct_customer_account_ctb ;

```

*  DEPENDENT UNION

UNION中的第二个或后面的SELECT语句，取决于外面的查询


```
explain select * from user where uid in (select uid from user union all select customer_uuid   from ct_customer_account_ctb);
```


* UNION RESULT

UNION的结果

```
 explain select uid from user union all select customer_uuid   from ct_customer_account_ctb
 
```


* SUBQUERY
子查询中的第一个SELECT.

```
explain  select * from user where  uid =(select uid from user limit 1);

```

*  DEPENDENT SUBQUERY

子查询中的第一个SELECT，取决于外面的查询


```
explain select * from user where uid in (select uid from user union all select customer_uuid   from ct_customer_account_ctb);


```

* DERIVED(派生)

```
explain select uid from (select * from user) a;
```

#### table
显示这个一行数据是关于哪张表的，
有时不是真实的表名字,看到的是derivedx(x是个数字)

```
explain select uid from (select * from (select * from user )b ) a;

```

#### type 
显示连接使用了什么类别
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
(一般来说，得保证查询至少达到range级别，最好能达到ref)

* system (表只满足一行条件)

```
 explain select * from (select * from user where uid=10001) a;

```

* const 
 表最多有一个匹配行，它将在查询开始时被读取

```
explain select * from user where uid=10001;

```

* eq_ref

 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。


```
explain select * from user u , ca_customer_account cb   where cb.customer_uuid=u.uuid ;

```


* ref

对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取,ref可以用于使用=或<=>操作符的带索引的列。


```

explain select * from user u , ct_customer_account_ctb cb   where cb.customer_uuid=u.uuid ;
```


*  `ref_or_null`

该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行

```
explain select user_type from user where user_type=0 or user_type is  null;


```

* index_merge

该联接类型表示使用了索引合并优化方法。

```
explain select * from t4 where id=3952602 or accountid=31754306 ;

```

* unique_subquery

该类型替换了下面形式的IN子查询的ref：

```
value IN (SELECT primary_key FROM single_table WHERE some_expr)
unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。

```

* index_subquery

该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：

```
value IN (SELECT key_column FROM single_table WHERE some_expr)

```

* range 

只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引

```
explain select * from user where uid =10035 or uid=10036;

```

* index 

该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。

* ALL

对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。


#### possible_keys

possible_keys列指出MySQL能使用哪个索引在该表中找到行,如果该列是NULL，则没有相关的索引


#### key

key列显示MySQL实际决定使用的键（索引）

#### key_len

key_len列显示MySQL决定使用的键长度

#### ref

列显示使用哪个列或常数与key一起从表中选择行。

#### rows

rows列显示MySQL认为它执行查询时必须检查的行数。

#### Extra

该列包含MySQL解决查询的详细信息,下面详细.

* Distinct 

一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 

* Not exists 

 MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了 
 
* .Range checked for each 

没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 

* Using filesort 

看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 

```
SELECT
	2 buyOrSell,
	ctb_trade_id,
	trade_no,
	buy_order_no,
	sell_order_no,
	customer_buy_uuid,
	customer_sell_uuid,
	currency_id,
	trade_num,
	trade_price,
	trade_amount,
	trade_time,
	buy_fee,
	sell_fee,
	risk_flag,
	STATUS,
	create_time,
	create_by,
	last_edit_time,
	last_edit_by
FROM
	tr_trade
WHERE
	customer_sell_uuid = 'e2aaadccb1ed4646ac9d5dbfa53df8cb'
AND STATUS = 1
AND currency_id = 30
AND base_currency_id = 3
UNION ALL
	SELECT
		1 buyOrSell,
		ctb_trade_id,
		trade_no,
		buy_order_no,
		sell_order_no,
		customer_buy_uuid,
		customer_sell_uuid,
		currency_id,
		trade_num,
		trade_price,
		trade_amount,
		trade_time,
		buy_fee,
		sell_fee,
		risk_flag,
		STATUS,
		create_time,
		create_by,
		last_edit_time,
		last_edit_by
	FROM
		tr_trade
	WHERE
		customer_buy_uuid = 'e2aaadccb1ed4646ac9d5dbfa53df8cb'
	AND STATUS = 1
	AND currency_id = 30
	AND base_currency_id = 3
	ORDER BY
		trade_no DESC
	LIMIT 0,
	10;


```





* Using index

列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 

* Using temporary

看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 

* Using where

使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题


## Mysql中的Btree与Hash索引

### B-Tree 索引特征

B-Tree索引可以被用在像=,>,>=,<,<=和BETWEEN这些比较操作符上。而且还可以用于LIKE操作符，只要它的查询条件是一个不以通配符开头的常量

 ```
 SELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';
 SELECT * FROM tbl_name WHERE key_col LIKE other_col;
 
 ```
 第一条是因为它以通配符开头，第二条是因为没有使用常量。
 
 
###  Hash索引
 
 1. 只能用于对等比较，例如=和<=>操作符（但是快很多）。它们不能被用于像<这样的范围查询条件。假如系统只需要使用像“键值对”的这样的存储结构，尽量使用hash类型索引。
优化器不能用hash索引来为ORDER BY操作符加速。（这类索引不能被用于搜索下一个次序的值）
2. MySQL不能判断出两个值之间有多少条数据（这需要使用范围查询操作符来决定使用哪个索引）。假如你将一个MyISAM表或InnoDB表转为一个依靠hash索引的MEMORY表，这可能会影响一些查询。
3. 只有完整的键才能被用于搜索一行数据（使用了B-Tree索引，那么任何一个键的前缀都可以用于查找）。
 
 
 
## mysql 引擎
 
 * InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
 * MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
* Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
* NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
* Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；

 

## 我自己的总结

### mysql连表更新

```

UPDATE user_points p,
 (
	SELECT
		uuid,
		sum(number) outnumber
	FROM
		user_itl_consume
	GROUP BY
		uuid
) outcome,
 (
	SELECT
		uuid,
		sum(number) innumber
	FROM
		user_itl_income
	GROUP BY
		uuid
) income
SET p.point = (
	income.innumber - outcome.outnumber
)
WHERE
	p.uuid = income.uuid
AND p.uuid = outcome.uuid
AND income.innumber - outcome.outnumber != p.point;



```


### 统计时候，cash when 

```

SELECT
	SUM(
		CASE
		WHEN buyOrSell = 1 THEN
			num * price
		ELSE
			0
		END
	) ,
	SUM(
		CASE
		WHEN buyOrSell = 2 THEN
			num * (-price)
		ELSE
			0
		END
	) c

FROM
	tr_order  having c>10;


```
###

备份数据库脚本

```

#!/bin/sh 
date=` date +%F`
echo $date
 mysqldump -h 172.0.0.1  -uroot -pcc cc  > /data/app/sql/cc-$date.sql


```

### 开启远端权限


```
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY '' WITH GRANT OPTION;

```

### mysql将结果导出文件或者excel

 
```
mysql -h 172.1.0.1  -uroot -pcc  --default-character-set=utf8 jeeplus_schema -e "select count(*),uname,phone from user group by uname  having count(*)>1;" > /tmp/repeat.txt

```

###  mysql 查看表占用

```

SELECT  *  FROM information_schema.TABLES WHERE  TABLE_SCHEMA='lian12'\G;





字段	含义
Table_catalog	数据表登记目录
Table_schema	数据表所属的数据库名
Table_name	表名称
Table_type	表类型[system view|base table]
Engine	使用的数据库引擎[MyISAM|CSV|InnoDB]
Version	版本，默认值10
Row_format	行格式[Compact|Dynamic|Fixed]
Table_rows	表里所存多少行数据
Avg_row_length	平均行长度
Data_length	数据长度
Max_data_length	最大数据长度
Index_length	索引长度
Data_free	空间碎片
Auto_increment	做自增主键的自动增量当前值
Create_time	表的创建时间
Update_time	表的更新时间
Check_time	表的检查时间
Table_collation	表的字符校验编码集
Checksum	校验和
Create_options	创建选项
Table_comment	表的注释、备注	


```










 
 


























































