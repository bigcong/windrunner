title: 面试1
author: bigcong
tags:
  - 总结
categories: []
date: 2017-04-15 13:25:00
---
### java的内存分配策略

*   程序运行当中，内存分为三种策略，分别是栈式，堆式，静态的，
*   静态分配是指在编译的时候每个数据目标在运行时刻所需要的存储空间，因此在编译的时候就可以给他们分配的固定的内存空间，这种分配策略要求程序代码当中不能有可变的数据结构（比如可变的数组结构），不允许有嵌套和递归结构出现，因为他们编译的时候无法准确计算出所需的存储空间
*   栈式存储分配也可以称为动态分配，和静态存储分配相反，栈式分配的时候，程序对数区的分配是完全未知的，只有运行的时候才知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块的所需的数据区的大小才能为其分配内存，栈式存储分配按照先进后出的原则进行分配的
*   堆式分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变的字符串和对象实例，堆由大片的可用块或者空闲块组成，堆的内存可以按照任意的分配和释放
   
### jvm的堆和栈

*	栈内存：一些基本类型的变量和对象的引用变量都是在函数的堆内存中分配的，java在栈中分配内存的时候，当超过变量的作用域的时候，java会自动释放为该变量分配的内存空间，该内存空间可以立即被另作他用
*   堆内存：用于存储new创建的对象和数组，jvm自动垃圾回收机制来管理。数组和对象在没有引用变量指向它的时候，就会变为垃圾，随后在一个不确定的时间会被垃圾回收机制释放掉，这也是java比较耗内存的原因
*    堆主要用来存储对象的，栈主要用来执行程序的
*   jvm是基于堆栈的虚拟机，jvm为每个新创建的线程分配一个堆栈，也就说
    它的运用基于堆栈操作来完成的

### java的equals和hashcode

*	java的数据类型分为两类，一类为基本数组类型（byte，short，char，int等），他们之间的比较，应用双等号，比较是他们的值，一类为引用类型（数组，类），比较的是他们内存存放地址，对象存放在堆中，栈中存放对象的引用地址
*    java的默认equals方法，是直接调用==，比较对象的地址
*    hashcode方法，直接返回32位对象在jvm的地址
*    很好理解，你和另一个人的体重（HASH CODE）可能一样，但是你们不是同一个人（EQUAL）

### mysql 索引原理

*	当数据存放在磁盘介质上的时候，它被当作一个整体来访问的，这样可以保持数据的原子性。数据存储的结构类似链表，都包含数据部分，以及一个指向下一个节点指针，不需要连续存储的
*    记录集如果在一个无序字段上进行排序的话，需要执行一个线性搜索（linear search），平均访问N/2的数据块，N代表数据块的数目。如果这个字段是一个非关键字段，那么需要N个数据块搜索整个表空间
*    但是对一个有序的字段，可以运用二分查找，这样只要访问log2的数据块
*    索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序
*   副作用就是索引需要额外的磁盘空间，对于myISAM引擎来说，这些索引是被统一保存到一张表中，这个文件很快达到了文件系统的支持的大小

### mysql 引擎


*    ISAM  
        * 优点：执行读取操作的速度很快，不占用内存和存储资源
        * 缺点：是不支持事务处理，如果硬盘崩溃了，那么数据文件就无法恢复，所以必须经常备份你所有的实时数据
        
* MyISAM  
	* 是ISAM扩展格式和缺省数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发对象操作。其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。myISAM还有一些有用的扩展，修复数据库文件和恢复浪费空间MYISAMPACk工具
	* MyISAM强调快速读取，在web开发中进行大量操作都是读取操作，大部分虚拟主句提供商只允许myISAM格式
* HEAP
	* 是允许只只驻留在内存的临时表格，驻留在内存的HEAP比ISAM和MyISAM多要快，但是管理数据是不稳定的，所以如果在关机之前没有保存数据的话，那么所有的数据都会丢失，在删除行的时候，HEAP不会浪费大量的空间。HEAP在使用select表达式来选择和操控数据的时候非常有用，在用完表格的时候，就删除表格
*	InnoDB和Berkley DB
	* 比ISAM和MYISAM慢的多，但是对事物的处理和外键的支持

### spring aop 原理

* OOP 引入了封装类，继承，多态等特性，用以模拟公共行为的集合，如果我们为对象引入一些公共的行为的部分的时候，oop就会引入重复的代码
*	Aop技术利用一种叫做横切的技术，解剖封装对象内部，并将那些的多个类的功能行为封装到一个可重用模块，降低了系统的代码的重复，降低了代码直接的耦合度，并且有利于未来的可操作性和可维护性。aop把系统分为两个模块，横切关注点和核心关注点。业务处理主要流程是核心关注点，与之不大的横切关注点
* aop的主要分为动态代理和静态代理
*	静态代理是指目标对象和代理对象实现共同的接口，并且对象有目标的引用
*	动态代理实现了InvocationHandler，并且将目标的对象注射到代理对象当中，并行通过反射机制来执行目标代码

### kafka如何避免丢消息

*	kafka生产者kakfaproducter.send方法仅仅是将消息队列放在一个缓存当中（recordaccumular）,本质上使用队列存储缓存记录，同时后台进程的IO线程不断扫描该区域，满足条件封装的时候，会将满足条件批次发送过去，如果这个过程有一个数据丢失的窗口，在io线程发送之前挂掉，就会可能丢数据
*	consumer端丢失消息的情形比较简单：如何消息处理完成前就提交了offset，那么就有可能造成丢数据，enable.auto.commit=false  关闭自动提交位移，在消息提交之后，在手动提交

### 同步异步和阻塞和非阻塞



### ArrayList和linkedList的区别
*	ArrayList的内部实现是基于对象数组的，因此get方法方法任意每一个元素的，它的速度都要比linkedList的速度要快，linkedlist的get方法是按照顺序从列表的一端开始检查，直到另一端，因为linkedList需要移动指针，linkedList是基于链表的数据结构的
*	但是当需要对列表进行大量的插入和删除操作的时候，linkedList的速度要比Arraylist要快，因为ArrayList每插入一条数据，都要移动插入点之后的所有数据
*	ArrayList使用是一个内部数组，这个数组初始值长度为10，当需要增长时，数组会增长为（旧容量*3）／2+1，每次大概增长50%，如果一个ArrayList包含大量的元素的时候，那么就会大量的空间会被浪费掉，如果知道ArrayList将会有多少个元素，我们可以构造方法来指定容量，我们还可以trimToSize去掉浪费的空间
*	ArrayList，LinkedList都是线程不安全的，Vector是线程安全的，是因为Vector加了线程锁
* 另外HashMap是非线程安全的，允许为null值作为key，，HashTable是线程安全的；StringBuilder是非线程安全的，StringBuffer是线程安全的。
*	数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区；   

### string ,StringBuilder,StringBuffer

*	String是不可变的对象，实际上在不断的创建新的对象，而原来的对象会变成垃圾不断的被GC回收，效率非常低下
*	StringBuilder和StringBuffer，是字符串变量，是可变的对象，对字符串操作的时候，不会创建额外的对象，减少了内存开销
*	StringBuilder是线程不安全的，适合单线，StringBuffer是线程安全的，适合多线程的 

### JVM内存管理
#### 堆

*	所有通过new关键字的对象的内存都在堆内存分配，其大小可以通过-Xmx，-Xms来控制。堆被划分为新生代和旧生代，新生代又被分为Eden和survivor，最后survivior是由from Space和to Space组成
    
##### 新生代

*	新建的对象都是由新生代分配内存的，Eden内存不足的时候，会把存活的对象转移到survivior,-XX:SurvivorRatio可以调节eden和survivor的比例
   

##### 旧生代

*	用以存放新生代中多次垃圾回收仍然存在的对象   

#### 栈

*	每个线程执行每个方法的时候，都会在栈中申请一个栈桢，每个栈桢包括局部变量区和操作数栈，用于存放调用过程中的临时变量，参数和中间结果   

#### 本地方法栈

*	用以支持native方法的执行，存储每个native的状态

#### 方法区
*	存放加载类的信息，静态变量，final类型的常量，属性和方法，jvm用持久化来存放方法区，-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值	

### 垃圾回收机制
#### 新生代GC

*	新生代通常存活时间很短，因此基于copying算法回收，就是扫描存活对象，并复制到一块未被使用的空间，即使从from space到to space，新生代采用空闲指针的方式来控制GC的触发，指针始终保持最后一个分配的对象，在新生代中，当由新的对象分配内存的时候，用以检查是否内存空间足够，不够就触发GC，当连续分配对象的时候，对象逐渐由eden到survivior，最后到旧生代，如果旧生代满了之后，outofmemory异常
*	在执行机制上提供了串行GC，并行回收GC和并行GC
*	串行GC，适用于当CPU，新生代空间较小以及暂停时间要求不高的应用上，client
*	并行回收GC，在整个扫描和复制过程当中采用多线程，适用于多CPU，暂停时间短的应用上，server
*	并行GC，与旧生代的并发GC配合使用

#### 旧生代GC
*	旧生代GC，对象存放时间长，比较稳定，采用mark标记算法来回收，所谓的标记就是扫描出存活的对象，然后再回收未被标记的对象，回收之后的空间进行合并，那么标记出来便于下次进行分配，总之减少内存随便带来的效率损耗
